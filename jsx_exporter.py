"""Generate JSX camera script for After Effects.

Produces JSX in the same format as Earth Studio's 3D Camera Export.
Run via File > Scripts > Run Script File... in After Effects
to auto-generate camera keyframes and Track Points.
"""
from __future__ import annotations

import math
from pathlib import Path

from models import CameraKeyframe, ShotPlan

EARTH_A = 6_378_137.0
EARTH_F = 1.0 / 298.257223563
EARTH_E2 = 2.0 * EARTH_F - EARTH_F * EARTH_F


def _geodetic_to_ecef(lat_deg: float, lng_deg: float, alt_m: float) -> tuple[float, float, float]:
    lat = math.radians(lat_deg)
    lng = math.radians(lng_deg)
    sin_lat, cos_lat = math.sin(lat), math.cos(lat)
    sin_lng, cos_lng = math.sin(lng), math.cos(lng)
    n = EARTH_A / math.sqrt(1.0 - EARTH_E2 * sin_lat * sin_lat)
    x = (n + alt_m) * cos_lat * cos_lng
    y = (n + alt_m) * cos_lat * sin_lng
    z = (n * (1.0 - EARTH_E2) + alt_m) * sin_lat
    return x, y, z


def _lerp(a: float, b: float, t: float) -> float:
    return a + (b - a) * t


def _lerp_angle(a: float, b: float, t: float) -> float:
    delta = ((b - a + 180.0) % 360.0) - 180.0
    return (a + delta * t + 360.0) % 360.0


def _interpolate(keyframes: list[CameraKeyframe], fps: int) -> list[dict]:
    if not keyframes or len(keyframes) < 2:
        return []
    duration = keyframes[-1].t
    total_frames = max(int(duration * fps), 1)
    frames: list[dict] = []
    ki = 0
    for fi in range(total_frames):
        t = fi / max(fps, 1)
        while ki < len(keyframes) - 2 and keyframes[ki + 1].t < t:
            ki += 1
        a = keyframes[ki]
        b = keyframes[min(ki + 1, len(keyframes) - 1)]
        span = max(b.t - a.t, 1e-8)
        p = max(0.0, min(1.0, (t - a.t) / span))
        lat = _lerp(a.lat, b.lat, p)
        lng = _lerp(a.lng, b.lng, p)
        alt = _lerp(a.alt_m, b.alt_m, p)
        heading = _lerp_angle(a.heading_deg, b.heading_deg, p)
        tilt = _lerp(a.tilt_deg, b.tilt_deg, p)
        ex, ey, ez = _geodetic_to_ecef(lat, lng, alt)
        frames.append({
            "x": ex, "y": ey, "z": ez,
            "rx": -tilt, "ry": -heading, "rz": 0.0,
            "frame": fi + 1,
        })
    return frames


def export_jsx(
    shot: ShotPlan,
    output_path: Path,
    *,
    fps: int = 24,
    width: int = 1920,
    height: int = 1080,
) -> None:
    """Export ShotPlan as an After Effects compatible JSX camera script."""
    frames = _interpolate(shot.keyframes, fps)
    if not frames:
        return

    total = len(frames)
    target_ecef = _geodetic_to_ecef(shot.target_lat, shot.target_lng, 0.0)

    lines: list[str] = []
    lines.append('// Generated by Aerial Cinematic Bot')
    lines.append(f'// Shot: {shot.title}')
    lines.append('')
    lines.append('{')
    lines.append(f'  var comp = app.project.items.addComp("{shot.title}", {width}, {height}, 1, {total}/{fps}, {fps});')
    lines.append('')
    lines.append('  var cam = comp.layers.addCamera("Earth Studio Camera", [comp.width/2, comp.height/2]);')
    lines.append('  cam.autoOrient = AutoOrientType.NO_AUTO_ORIENT;')
    lines.append('')

    # Position keyframes
    lines.append('  var posProp = cam.property("ADBE Transform Group").property("ADBE Position");')
    for f in frames:
        lines.append(f'  posProp.setValueAtTime({(f["frame"]-1)/fps}, [{f["x"]:.4f}, {f["y"]:.4f}, {f["z"]:.4f}]);')

    lines.append('')

    # Orientation keyframes
    lines.append('  var oriProp = cam.property("ADBE Transform Group").property("ADBE Orientation");')
    for f in frames:
        lines.append(f'  oriProp.setValueAtTime({(f["frame"]-1)/fps}, [{f["rx"]:.4f}, {f["ry"]:.4f}, {f["rz"]:.4f}]);')

    lines.append('')

    # Track point (target)
    lines.append(f'  var tp = comp.layers.addNull();')
    lines.append(f'  tp.name = "Target";')
    lines.append(f'  tp.threeDLayer = true;')
    lines.append(f'  tp.property("ADBE Transform Group").property("ADBE Position").setValue([{target_ecef[0]:.4f}, {target_ecef[1]:.4f}, {target_ecef[2]:.4f}]);')
    lines.append('')

    # Label text
    lines.append(f'  var label = comp.layers.addText("Target");')
    lines.append(f'  label.parent = tp;')
    lines.append(f'  label.property("ADBE Transform Group").property("ADBE Position").setValue([0, 0, 0]);')

    lines.append('}')

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text('\n'.join(lines), encoding='utf-8')
